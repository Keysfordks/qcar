import cv2
import torch
import threading
import torchvision


from ultralytics import YOLO

class YOLODetector(threading.Thread):
    def __init__(self, qcar, update_callback, image_callback, qcar_lock):
        super(YOLODetector, self).__init__()
        self.qcar = qcar
        self.update_callback = update_callback
        self.image_callback = image_callback
        self.qcar_lock = qcar_lock
        self.running = True

        # Load pretrained YOLOv8n model
        self.model = YOLO("yolov8n.pt")
        self.model.to('cpu')

        # Class mappings
        self.stop_classes = {11}  # stop sign
        self.slow_classes = {0}   # person

    def run(self):
        while self.running:
            with self.qcar_lock:
                success, rgb = self.qcar.get_image(camera=self.qcar.CAMERA_CSI_FRONT)

            if not success or rgb is None:
                continue

            rgb_input = cv2.cvtColor(rgb, cv2.COLOR_BGR2RGB)
            results = self.model.predict(rgb_input, verbose=False)
            results = results[0] if isinstance(results, list) else results

            annotated = rgb.copy()
            signal = "GO"

            for box in results.boxes:
                cls_id = int(box.cls[0])
                conf = float(box.conf[0])
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                label = self.model.names[cls_id]

                color = (0, 255, 0)
                if cls_id in self.stop_classes:
                    signal = "STOP"
                    color = (0, 0, 255)
                elif cls_id in self.slow_classes:
                    if signal != "STOP":
                        signal = "SLOW"
                    color = (0, 255, 255)

                cv2.rectangle(annotated, (x1, y1), (x2, y2), color, 2)
                cv2.putText(annotated, f"{label} {conf:.2f}", (x1, y1 - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
            print(f"[YOLO] Detections: {[self.model.names[int(box.cls[0])] for box in results.boxes]}")
            print("Image shape:", rgb.shape)
            print("Image dtype:", rgb.dtype)
            self.update_callback(signal)
            self.image_callback(annotated)
            cv2.waitKey(1)

    def stop(self):
        self.running = False
